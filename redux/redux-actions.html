
<link rel="import" href="redux-action-types.js">

<script>
    var Ordercloud = window.Ordercloud || {};
    (function() {


        /**
         * Gets the logged in user
         * @returns {{type}}
         */
        function requestUser() {
            return {
                type: REQUEST_USER
            }
        }

        /**
         * Set the logged in user
         * @param payload
         * @returns {{type, user: *, receivedAt: number}}
         */
        function receiveUser (payload) {
            return {
                type: RECEIVE_USER,
                user: payload,
                receivedAt: Date.now()
            }
        }

        function fetchUser(state) {
            return dispatch => {
                dispatch(requestUser());
                return fetch(_generateRequest('/users/logged_in', state))
                    .then(response => response.json())
                    .then(json => dispatch(receiveUser(json)))
            }
        }

        function shouldFetchUser(state) {
            const user = state.identity.user;
            if (!user) {
                return true
            } else if (user.isFetching) {
                return false
            } else {
                return user.didInvalidate
            }
        }

        function fetchUserIfNeeded() {
            // Note that the function also receives getState()
            // which lets you choose what to dispatch next.

            // This is useful for avoiding a network request if
            // a cached value is already available.

            return (dispatch, getState) => {
                if (shouldFetchUser(getState())) {
                    // Dispatch a thunk from thunk!
                    return dispatch(fetchUser(getState()));
                } else {
                    // Let the calling code know there's nothing to wait for.
                    return Promise.resolve();
                }
            }
        }


        /**
         * Set the logged in user
         * @returns {{type}}
         */
        function loginUser (payload) {
            return {
                type: LOGIN_USER,
                token: payload
            }
        }

        /**
         * Set the logged in user
         * @returns {{type}}
         */
        function logoutUser () {
            return {
                type: LOGOUT_USER
            }
        }

        /**
         * Clear the token
         * @returns {{type}}
         */
        function clearToken () {
            return {
                type: CLEAR_TOKEN,
                receivedAt: Date.now()
            }
        }

        /**
         * Set the current organisation
         * @param payload
         * @returns {{type, profile: *,id : number, receivedAt: number}}
         */
        function receiveOrganisation (payload) {
            return {
                type: RECEIVE_ORGANISATION,
                profile: payload.profile,
                id: payload.id,
                receivedAt: Date.now()
            }
        }


        function fetchOrganisation(id, state) {
            return dispatch => {
                dispatch(requestUser());
                return fetch(_generateRequest('/organisation/' + id, state))
                    .then(response => response.json())
                    .then(json => dispatch(receiveOrganisation(json)))
            }
        }


        function shouldFetchOrganisation(id,state) {
            const organisation = state.organisation.profile;
            if ((!organisation) || (organisation.profile.id !== id)) {
                return true
            } else if (organisation.isFetching) {
                return false
            } else {
                return organisation.didInvalidate
            }
        }

        function fetchOrganisationIfNeeded(id) {
            // Note that the function also receives getState()
            // which lets you choose what to dispatch next.

            // This is useful for avoiding a network request if
            // a cached value is already available.

            return (dispatch, getState) => {
                if (shouldFetchOrganisation(id, getState())) {
                    // Dispatch a thunk from thunk!
                    return dispatch(fetchOrganisation(id, getState()));
                } else {
                    // Let the calling code know there's nothing to wait for.
                    return Promise.resolve();
                }
            }
        }


        /**
         * Clears the organisation data
         * @returns {{type}}
         */
        function clearOrganisation () {
            return {
                type: CLEAR_ORGANISATION
            }
        }

        /**
         *
         * @param payload
         * @returns {{type, clientId: *, receivedAt: number}}
         */
        function receiveClientId (payload) {
            return {
                type: RECEIVE_CLIENT_ID,
                clientId: payload,
                receivedAt: Date.now()
            }
        }

        /**
         * Generates a valid api url by prepending thhe host and adding resource/ before the rest of the path
         * @param uri un generated uri on containing the path after /resource in api-docs
         * @returns {string} uri that has the host and /resource prepended
         */
        function _generateUrl(uri, state){
            return state.config.apiHostUrl + 'resource/' + uri;
        }

        function _generateRequest (request) {
            return _generateRequest(request, false);
        }

        function _generateRequest (uri, state, marketplace) {

            var myHeaders = new Headers();

            //check if the call is a marketplace connection
            let clientId =  state.config.clientId;
            if(!marketplace){
                clientId = Ordercloud.select.clientId(state);
            }

            myHeaders.append('Authorization', 'Bearer ' + state.identity.token);
            myHeaders.append('X-Ordercloud-Organisation', clientId);

            var myInit = { method: 'GET',
                headers: myHeaders,
                mode: 'cors',
                cache: 'default' };

            return  new Request(uri, myInit);

        }

        /**
         *
         * @param payload
         * @returns {{type, clientId: *, receivedAt: number}}
         */
        function receiveConfig (payload) {
            return {
                type: RECEIVE_CONFIG,
                clientId: payload.clientId,
                organisationId: payload.organisationId,
                tokenRedirectUri: payload.tokenRedirectUri,
                authClientId: payload.authClientId,
                authHostUrl: payload.authHostUrl,
                apiHostUrl: payload.apiHostUrl,
                environment: payload.environment,
                receivedAt: Date.now()
            }
        }

        Ordercloud.actions = {
            receiveUser,
            loginUser,
            logoutUser,
            clearToken,
            receiveOrganisation,
            clearOrganisation,
            receiveClientId,
            receiveConfig,
            fetchUserIfNeeded,
            fetchOrganisationIfNeeded
        }

    }());
</script>